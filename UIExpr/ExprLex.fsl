// Expr{Parse,Lex} generated by
//$ /cygdrive/c/Program\ Files/FSharpPowerPack-2.0.0.0/bin/fslex.exe --unicode ExprLex.fsl &&
//  /cygdrive/c/Program\ Files/FSharpPowerPack-2.0.0.0/bin/fsyacc.exe --module ExprParse ExprParse.fsy
{
module ExprLex

open System
open Microsoft.FSharp.Text.Lexing

open ExprParse

let lexeme lexbuf = LexBuffer<char>.LexemeString lexbuf
}

// regex defns
let digit    = ['0'-'9']
let alpha    = ['A'-'Z' 'a'-'z' '_']
let alphadigit = alpha | digit	
//let letdig   = ['0'-'9' 'a'-'z' 'A'-'Z' '_' ]
//let alphlet  = ['A'-'Z' 'a'-'z' '_' '$' '\'' ]
let ws       = [' ' '\009' '\012']

// lexer entry point
rule tokenize = parse
    '\r'                { tokenize lexbuf }
  | '\n'                { tokenize lexbuf }
  | ws                  { tokenize lexbuf }

  | "var"               { VAR }
  | "pos"               { POS } 
  | "neg"               { NEG } 
  | "avg"               { AVG }
  | "max"               { MAX }
  | "min"               { MIN }
  | "ceil"              { CEIL }
  | "floor"             { FLOOR }

  | ','                 { COMMA }
  | '('                 { LPAREN }
  | ')'                 { RPAREN }
  | '+'                 { PLUS }
  | '-'                 { MINUS }
  | "*"                 { TIMES }
  | '/'                 { DIV  }
//  | ['-']?digit+	    { NUM(Int32.Parse(lexeme lexbuf)) }
  | alpha alphadigit*   { IDENT(lexeme lexbuf) }  
  | digit+      	    { NUM(Int32.Parse(lexeme lexbuf)) }

  | eof                 { EOF }

