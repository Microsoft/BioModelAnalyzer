//need to handle unary operators
//temporal and logic

import { Token } from 'chevrotain'
import * as _ from 'underscore'
import { TokenType } from './NLParser'
/**
 * Util functions that handle printing of the AST generated by the parser
 */
export function toHumanReadableString(AST, bmaModel) {
    var reversePolishTokens = [];
    performPostOrderTraversal(AST, reversePolishTokens, bmaModel);
    return convertReversePolishFormulaToInfix(reversePolishTokens.reverse())
}

function performPostOrderTraversal(node, outputTokens, bmaModel) {
    if (node.left) {
        performPostOrderTraversal(node.left, outputTokens, bmaModel);
    }
    if (node.right) {
        performPostOrderTraversal(node.right, outputTokens, bmaModel);
    }
    if (node.value) {
        if (node.type == "relationalExpression") {
            if (node.left.type === "modelVariable") {
                let left = _.find(bmaModel.Model.Variables, (v: any) => v.Id === node.left.id).Name
                left = left.indexOf(' ') >= 0 ? "(" + left + ")" : left
                outputTokens.unshift(left + node.value.value + node.right);
            } else {
                throw Error("relationalExpression must be of the form modelVariable(arithmetic operator)integer")
            }
        }
        else if (node.value.type === "binaryOperator") {
            outputTokens.unshift(node.value.value);
        }
        else {
            outputTokens.unshift(node.value);
        }
    }
}
function convertReversePolishFormulaToInfix(reversePolishTokens) {
    var stack = [];
    _.each(reversePolishTokens, function (t: any) {
        if (t.TOKEN_TYPE === TokenType.LOGICAL_BINARY) {
            if (stack.length < 2) {
                throw Error("Parse Exception");
            }
            else {
                var varX = stack.pop()
                var varY = stack.pop()
                stack.unshift("(" + varY + " " + t.LABEL + " " + varX + ")");
            }
        } else if (t.TOKEN_TYPE == TokenType.LOGICAL_UNARY && stack.length >= 1) {
            var varX = stack.pop()
            stack.unshift(t.LABEL + "(" + varX + ")");
        }
        else {
            stack.push(t);
        }
    });
    //handle remaining unary operators
    stack = stack.reverse();
    while (stack.length > 1) {
        var formula = stack.pop();
        var operator = stack.pop();
        stack.push(operator.LABEL + "(" + formula + ")");
    }
    return stack[0];
}