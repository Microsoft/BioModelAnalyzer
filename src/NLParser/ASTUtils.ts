import { Token } from 'chevrotain'
import * as _ from 'underscore'
import { TokenType } from './NLParser'
/**
 * Util functions that handle printing of the AST generated by the parser
 */
export function toHumanReadableString(AST, bmaModel) {
    var reversePolishTokens = [];
    toReversePolishFormula(AST, reversePolishTokens, bmaModel);
    return convertReversePolishFormulaToInfix(reversePolishTokens.reverse())
}

function toReversePolishFormula(node, outputTokens, bmaModel) {
    if (node.left) {
        toReversePolishFormula(node.left, outputTokens, bmaModel);
    }
    if (node.right) {
        toReversePolishFormula(node.right, outputTokens, bmaModel);
    }
    if (node.value) {
        if (node.type == "relationalExpression") {
            let left = _.find(bmaModel.Model.Variables, (v: any) => v.Id === node.left.id).Name
            //Add brackets if the variable name has space in it eg: protein and molecule => (protein and molecule) 
            left = left.indexOf(' ') >= 0 ? "(" + left + ")" : left
            outputTokens.unshift(left + node.value.value + node.right);
        }
        else if (node.value.type === TokenType.BINARY_OPERATOR) {
            outputTokens.unshift(node.value.value);
        }
        else {
            outputTokens.unshift(node.value);
        }
    }
}
function convertReversePolishFormulaToInfix(reversePolishTokens) {
    var stack = [];
    _.each(reversePolishTokens, function (t: any) {
        if (t.TOKEN_TYPE === TokenType.BINARY_OPERATOR) {
            if (stack.length < 2) {
                throw Error("Parse Exception");
            }
            else {
                var varX = stack.shift()
                var varY = stack.shift()
                stack.unshift("(" + varY + " " + t.LABEL + " " + varX + ")");
            }
        } else if (t.TOKEN_TYPE == TokenType.UNARY_OPERATOR && stack.length >= 1) {
            var varX = stack.shift()
            stack.unshift(t.LABEL + "(" + varX + ")");
        }
        else {
            stack.unshift(t);
        }
    });
    //handle remaining unary operators
    while (stack.length > 1) {
        var formula = stack.shift();
        var operator = stack.shift();
        stack.push(operator.LABEL + "(" + formula + ")");
    }
    return stack[0];
}