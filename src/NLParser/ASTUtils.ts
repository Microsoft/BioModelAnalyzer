import * as _ from 'underscore'
import { TokenType } from './NLParser'
import * as BMA from '../BMA'

// TODO create interfaces for AST tree

/**
 * Return a human readable formula string of an AST generated by the parser.
 * This string is in a specific format that can be read by the BMA tool.
 * 
 * @param node The AST.
 * @param bmaModel The BMA model.
 */
export function toHumanReadableString (node, bmaModel: BMA.ModelFile) {
    let varName = id => _.find(bmaModel.Model.Variables, v => v.Id === id).Name

    let left = node.left ? toHumanReadableString(node.left, bmaModel) : null
    let right = node.right ? toHumanReadableString(node.right, bmaModel) : null

    if (typeof node === 'string' || typeof node === 'number') {
        return node
    } else if ('id' in node) {
        // FIXME missing .type for variable nodes
        
        let name = varName(node.id)
        return name.indexOf(' ') >= 0 ? '(' + name + ')' : name
    } else if (node.type === 'relationalExpression') {
        return left + node.value.value + right
    } else if (node.type === TokenType.BINARY_OPERATOR || (node.value && node.value.TOKEN_TYPE === TokenType.BINARY_OPERATOR)) {
        // FIXME should be unified and not rely on token function properties

        return '(' + left + ' ' + node.value.LABEL + ' ' + right + ')'
    } else if (node.type === TokenType.UNARY_OPERATOR || (node.value && node.value.TOKEN_TYPE === TokenType.UNARY_OPERATOR)) {
        return node.value.LABEL + '(' + left + ')'
    } else {
        return left
    }
}

/**
 * Return a BMA REST API-compatible formula string of an AST generated by the parser.
 * 
 * @param node The AST.
 * @param bmaModel The BMA model.
 */
export function toAPIString (node, bmaModel: BMA.ModelFile) {
    let varName = id => _.find(bmaModel.Model.Variables, v => v.Id === id).Name
    let upper = (s: string) => s[0].toUpperCase() + s.substr(1)

    let left = node.left ? toAPIString(node.left, bmaModel) : null
    let right = node.right ? toAPIString(node.right, bmaModel) : null

    if (typeof node === 'string' || typeof node === 'number') {
        return node
    } else if ('id' in node) {
        return node.id
    } else if (node.type === 'relationalExpression') {
        return '(' + node.value.value + ' ' + left + ' ' + right + ')'
    } else if (node.type === TokenType.BINARY_OPERATOR || (node.value && node.value.TOKEN_TYPE === TokenType.BINARY_OPERATOR)) {
        return '(' + upper(node.value.LABEL) + ' ' + left + ' ' + right + ')'
    } else if (node.type === TokenType.UNARY_OPERATOR || (node.value && node.value.TOKEN_TYPE === TokenType.UNARY_OPERATOR)) {
        return '(' + upper(node.value.LABEL) + ' ' + left + ')'
    } else {
        return left
    }
}

/**
 * Separates an AST into an LTL formula and states.  
 * The result can be used within a BMA model file. New state names are guaranteed to not
 * collide with names of the input model.
 */
export function toStatesAndFormula (node, bmaModel: BMA.ModelFile): BMA.Ltl {
    let varName = id => _.find(bmaModel.Model.Variables, v => v.Id === id).Name

    // A-Z
    let letters: string[] = Array.apply(0, Array(26)).map((x, y) => String.fromCharCode(65 + y))

    let states = bmaModel.ltl.states.slice()
    let unusedStateName = () => _.find(letters, letter => !states.some(state => state.name === letter))

    function walk (node, states: BMA.LtlState[]): BMA.LtlFormula  {
        if (node.type === 'relationalExpression') {
            let stateName = unusedStateName()
            let relationalExpression: BMA.LtlCompactStateRelationalExpression = {
                variableName: varName(node.left.id),
                variableId: node.left.id,
                operator: node.value.value,
                value: node.right
            }
            states.push(new BMA.LtlStateImpl(stateName, [relationalExpression]))
            return new BMA.LtlNameStateReferenceImpl(stateName)
        } else if (node.type === TokenType.BINARY_OPERATOR || (node.value && node.value.TOKEN_TYPE === TokenType.BINARY_OPERATOR)) {
            // check for AND-nested relationalExpression tree
            // this becomes a state
            
            // FIXME don't use LABEL for testing
            if (node.value.LABEL == 'and' && node.left.type === 'relationalExpression') {
                let relExprs = [node.left]
                let curNode = node.right
                while (curNode.value.LABEL == 'and' && curNode.left.type === 'relationalExpression') {
                    relExprs.push(curNode.left)
                    curNode = curNode.right
                }
                let stateName = unusedStateName()
                if (curNode.type === 'relationalExpression') {
                    // we can completely collapse the AND-tree to a state
                    relExprs.push(curNode)

                    let relationalExpressions: BMA.LtlCompactStateRelationalExpression[] = relExprs.map(relExprNode => ({
                        variableName: varName(relExprNode.left.id),
                        variableId: relExprNode.left.id,
                        operator: relExprNode.value.value,
                        value: relExprNode.right
                    }))

                    states.push(new BMA.LtlStateImpl(stateName, relationalExpressions))
                    return new BMA.LtlNameStateReferenceImpl(stateName)
                } else {
                    // more nodes are coming
                    let relationalExpressions: BMA.LtlCompactStateRelationalExpression[] = relExprs.map(relExprNode => ({
                        variableName: varName(relExprNode.left.id),
                        variableId: relExprNode.left.id,
                        operator: relExprNode.value.value,
                        value: relExprNode.right
                    }))

                    states.push(new BMA.LtlStateImpl(stateName, relationalExpressions))
                    // A and <rest>
                    return new BMA.LtlOperationImpl(node.value.LABEL, [new BMA.LtlNameStateReferenceImpl(stateName), walk(curNode, states)])
                }
            } else {
                return new BMA.LtlOperationImpl(node.value.LABEL, [walk(node.left, states), walk(node.right, states)])
            }

        } else if (node.type === TokenType.UNARY_OPERATOR || (node.value && node.value.TOKEN_TYPE === TokenType.UNARY_OPERATOR)) {
            return new BMA.LtlOperationImpl(node.value.LABEL, [walk(node.left, states)])
        } else {
            return walk(node.left, states)
        }
    }

    let simplifiedAST = simplifyAST(node)
    //console.log(JSON.stringify(simplifiedAST, null, 2))
    let formula = walk(simplifiedAST, states)
    return {
        operations: [formula] as BMA.LtlOperation[], // FIXME remove cast
        states
    }
}

/** Removes all redundant nodes in the tree to make processing easier. */
export function simplifyAST (node) {
    if (typeof node === 'string' || typeof node === 'number') {
    } else if ('id' in node) {
    } else if (node.type === 'relationalExpression') {
    } else if (node.type === TokenType.BINARY_OPERATOR || (node.value && node.value.TOKEN_TYPE === TokenType.BINARY_OPERATOR)) {
        node.left = simplifyAST(node.left)
        node.right = simplifyAST(node.right)
    } else if (node.type === TokenType.UNARY_OPERATOR || (node.value && node.value.TOKEN_TYPE === TokenType.UNARY_OPERATOR)) {
        node.left = simplifyAST(node.left)
    } else {
        node = simplifyAST(node.left)
    }
    return node
}