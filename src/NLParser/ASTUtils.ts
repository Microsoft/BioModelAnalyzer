//need to handle unary operators
//temporal and logic

import { Token } from 'chevrotain'
import * as _ from 'underscore'
/**
 * Util functions that handle printing of the AST generated by the parser
 */
export function toHumanReadableString(AST) {
    var reversePolishTokens = [];
    performPostOrderTraversal(AST, reversePolishTokens);
    return convertReversePolishFormulaToInfix(reversePolishTokens)
}

function performPostOrderTraversal(node, outputTokens) {
    if (node.left) {
        performPostOrderTraversal(node.left, outputTokens);
    }
    if (node.right) {
        performPostOrderTraversal(node.right, outputTokens);
    }
    if (node.value) {
        if (node.type == "relationalExpression") {
            outputTokens.unshift(node.left);
            outputTokens.unshift(node.value.value);
            outputTokens.unshift(node.right);
        }
        else if (node.value.type === "binaryOperator") {
            outputTokens.unshift(node.value.value);
        }
        else {
            outputTokens.unshift(node.value);
        }
    }
}
function convertReversePolishFormulaToInfix(reversePolishTokens) {
    var stack = [];
    _.each(reversePolishTokens, function (t: any) {
        if (t.IS_BINARY_LOGIC_OPERATOR) {
            if (stack.length < 2) {
                throw Error("Parse Exception");
            }
            else {
                var varX = stack.pop()
                var varY = stack.pop()
                stack.unshift("(" + varY + " " + t.LABEL + " " + varX + ")");
            }
        }
        else {
            stack.push(t);
        }
    });

    while (stack.length > 1) {
        stack.unshift(stack.pop().LABEL + "(" + stack.pop() + ")")
    }
    return stack[0]
}