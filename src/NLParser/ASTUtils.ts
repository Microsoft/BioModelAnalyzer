import { Token } from 'chevrotain'
import * as _ from 'underscore'
import { TokenType } from './NLParser'
import { ModelFile } from '../BMA'

// TODO create interfaces for AST tree

/**
 * Util functions that handle printing of the AST generated by the parser
 * 
 * @param node The AST.
 * @param bmaModel The BMA model.
 */
export function toHumanReadableString(node, bmaModel: ModelFile) {
    let varName = id => _.find(bmaModel.Model.Variables, v => v.Id === id).Name

    if (typeof node === 'string' || typeof node === 'number') {
        return node
    } else if ('id' in node) {
        // FIXME missing .type for variable nodes

        let name = varName(node.id)
        if (name.indexOf(' ') !== -1) {
            name = '(' + name + ')'
        }
        return name
    } else if (node.type === 'relationalExpression') {
        return toHumanReadableString(node.left, bmaModel) + node.value.value + toHumanReadableString(node.right, bmaModel)
    } else if (node.type === TokenType.BINARY_OPERATOR || (node.value && node.value.TOKEN_TYPE === TokenType.BINARY_OPERATOR)) {
        // FIXME should be unified and not rely on token function properties

        let left = toHumanReadableString(node.left, bmaModel)
        let right = toHumanReadableString(node.right, bmaModel)
        return '(' + left + ' ' + node.value.LABEL + ' ' + right + ')'
    } else if (node.type === TokenType.UNARY_OPERATOR || (node.value && node.value.TOKEN_TYPE === TokenType.UNARY_OPERATOR)) {
        let left = toHumanReadableString(node.left, bmaModel)
        return node.value.LABEL + '(' + left + ')'
    } else {
        return toHumanReadableString(node.left, bmaModel)
    }
}
